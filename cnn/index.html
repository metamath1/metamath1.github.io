<!DOCTYPE html>
<html lang="ko">
    <head>
        <title>CNN 역전파를 이해하는 가장 쉬운 방법</title>
        <meta charset="utf-8">
        <link rel="stylesheet" href="../style.css">
        <meta property="og:url" content="https://metamath1.github.io/cnn/index.html">
        <meta property="og:type" content="website">
        <meta property="og:title" content="CNN 역전파를 이해하는 가장 쉬운 방법">
        <meta property="og:description" content="본 문서의 목적은 CNN(Convolution Neural Network)의 역전파Back propagation 알고리즘을 정리하기 위해 
                간단한 CNN 모델을 정의하고 정의된 모델에 해당하는 수식을 완전히 유도하는 것 입니다. ">
        <meta property="og:image" content="https://metamath1.github.io/cnn/images/fig1.png">
    </head>
    <body>
        <!--본문-->
        <!--https://ko.wikipedia.org/wiki/%EC%9C%84%ED%82%A4%EB%B0%B1%EA%B3%BC:TeX_%EB%AC%B8%EB%B2%95-->
        <!---https://developers.facebook.com/tools/debug/og/object/-->
        <div class="row cnn" style="margin-top:30px;">
            <div class="col-md-offset-2 col-md-8">
                <h1>CNN 역전파를 이해하는 가장 쉬운 방법<br/> The easist way to understand CNN backpropagation </h1>
            </div> 
        </div>  
        <br/><br/>
        <div class="row cnn">
            <div class="col-md-offset-2 col-md-8">
                <h3>1. 이 글의 목적과 작성동기 </h3>
                본 문서의 목적은 CNN(Convolution Neural Network)의 역전파Back propagation 알고리즘을 정리하기 위해 
                간단한 CNN 모델을 정의하고 정의된 모델에 해당하는 수식을 완전히 유도하는 것 입니다. 
                정식 논문은 현학적 표현 때문에 수학 및 배경지식이 많지 않은 비전공자가 읽기 힘듭니다. 
                그리고 인터넷에 있는 많은 보조 문서들은 CNN을 전체적으로 조망하지 않고 일부 수식만을 설명 하기 
                때문에 초심자로써 CNN 역전파 알고리즘에 대해 포괄적으로 이해하기가 매우 어렵습니다. 
                더구나 그런 문서들은 사용하는 기호와 인덱스 기술 방법이 모두 다르고(수식에 rot180() 이나 flip(), up-sampling()같은 
                잘모르는 연산자가 등장한다거나, 인덱스를 0부터 쓰는 문서와 1부터 쓰는 문서를 함께 보면 보는 입장에서 매우 혼란스러움), 
                거의 모두 영어로 되어 있어 초심자의 접근을 더욱 어렵게 만듭니다. 
                따라서 CNN 역전파 알고리즘을 처음부터 끝까지 하나의 문서에 통일된 기호를 사용하여 기술한 한글 문서가 있으면 
                좋겠단 생각을 하였고, 이 문서를 작성하게 되었습니다. 
            </div> 
        </div>  
        <br/><br/>
        <div class="row cnn">
            <div class="col-md-offset-2 col-md-8">
                <h3>2. 이 글을 읽기 위한 요구사항 및 범위 </h3>
                이 글을 읽기 전에 각 층Layer이 벡터로 구성된 가장 기본적인 NN(Neural Network)에서 
                역전파 알고리즘을 꼭 이해하여야 합니다. 
                이를 위해서는 Michael Nielsen씨가 쓴 문서[1]에서 2장을 읽어보는 것이 좋습니다. 
                이 글의 기호 역시 Nielsen 문서와 동일하게 할 것입니다. 
                그리고 CNN에 대한 전반적인 상황은 이해를 하여야 합니다. 
                구체적인 수식을 이해할 필요는 없지만 입력의 모양과 필터의 모양 풀링Pooling의 의미 등은 
                대강 파악하고 있어야 합니다. 
                마지막으로 이 글의 범위는 각 학습 변수들에 대한 코스트 함수의 편미분 값을 구하는 것까지 입니다. 
                Mini-batch와 SGD(Stochastic Gradient Decent)를 사용하여 실제로 학습 변수를 업데이트하는 것은 
                포함되지 않습니다.
            </div>
        </div>
        <br/><br/>
        <div class="row cnn">
            <div class=" col-md-offset-2 col-md-8">
                <h3>3. 표기법(Notation)  </h3>
                간단히 표기법을 정리하였습니다. 
                표기법은 앞서 밝힌 대로 Nielsen 문서와 동일합니다. Nielsen 문서를 대충이라도 읽어 볼 것을 강력히 추천합니다.
                <br/><br/>
                <ul>
                    <li>1. 인덱스 : 모든 인덱스는 0에서 시작합니다</li>
                    <li>2. 행렬에서 행과 열의 크기는 해당 인덱스의 대문자를 사용합니다.</li>
                    <li>3. <span class="math-tex">\( C \) </span> : 코스트 함수를 나타냅니다.</li>
                    <li>4. <span class="math-tex">\( L, l \) </span> :	<span class="math-tex">\( L, l \) </span>번째 층, 특히 대문자 <span class="math-tex">\( L \) </span>은 출력층을 나타냅니다.</li>
                    <li>5. 
                    <span class="math-tex">\( w^{l}_{ij} \)</span> : 
                    <span class="math-tex">\(l-1\)</span>번째 층과 <span class="math-tex">\( l\) </span>번째 층을 연결하는 가중치weight의 <span class="math-tex">\(i, j\) </span>번째 요소입니다. 
                    완전 연결층Fully connected layer인 경우 <span class="math-tex">\(j\) </span>가 <span class="math-tex">\(l-1\) </span>번째 층의 인덱스, 
                    <span class="math-tex">\(i\) </span>가 <span class="math-tex">\(l\) </span>번째 층의 인덱스임을 유의해야 합니다. 
                    </li>
                    <li>6. 	<span class="math-tex">\( z_{ij}^{l} \)</span> : <span class="math-tex">\( l \)</span>번째 층의 가중합weighted sum의 <span class="math-tex">\( i, j \)</span>번째 요소입니다.</li>
                    <li>7. 	<span class="math-tex">\( a_{ij}^l \)</span> : <span class="math-tex">\(l\)</span>번째 층의 활성값activation value의 <span class="math-tex">\( i, j \)</span>번째 요소입니다.</li>
                    <li>8. 	<span class="math-tex">\(\sigma(x) \)</span>: 활성화 함수를 나타냅니다.</li>
                    <li>9. 가중치, 바이어스, 가중합, 활성값 벡터 또는 행렬은 모두 볼드 문자로 표시합니다.</li>
                    <li>10. 모든 식은 특별히 언급이 없는 한 인덱스 표기법을 기본으로 사용합니다.</li>
                </ul>
            </div>
        </div>
        <br/><br/>
        <div class="row cnn">
            <div class=" col-md-offset-2 col-md-8">
                <h3>4. NN의 역전파 알고리즘 수식</h3>
                CNN에서 역전파 알고리즘의 수식이 NN에서의 그것과 수학적으로 동일한 것이므로 NN의 수식을
                언급하지 않을 수 없습니다. CNN에서의 수식은 각 층의 연결 상태에 따라 내적Dot product이 
                컨벌루션Convolution 또는 코릴레이션Correlation으로 바뀐 것이기 때문에 우리의 논의는 NN의 수식으로부터 출발합니다. 
                다음 4개의 수식을 Nielsen 문서에서와 같이 순서대로 (BP1), (BP2), (BP3), (BP4)로 표시합니다.
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ \delta^{L}_{j} = \frac{ \partial C } { \partial a^{L}_{j} } \sigma'(z^{L}_{j}) $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                        (BP1)
                    </div>
                </div>
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ \delta^{l}_{j} = \sum_{k} w^{l+1}_{kj} \delta^{l+1}_{k} \sigma'(z^{l}_{j}) $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                        (BP2)
                    </div>
                </div>
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ \frac{ \partial C } { \partial b^{l}_{j} } = \delta^{l}_{j} $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                        (BP3)
                    </div>
                </div>
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ \frac{ \partial C } { \partial w^{l}_{jk} } = a^{l-1}_{k} \delta^{l}_{j} $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                        (BP4)
                    </div>
                </div>
               
                (BP1)과 (BP2)를 이용하여 모든 층의 <span class="math-tex">\( \delta \)</span>를 구하고 
                그 <span class="math-tex">\( \delta \)</span>를 이용하여 (BP3), (BP4)를 통해 코스트함수의 편미분 값을 구할 수 있습니다. 
                CNN에서는 위 수식 중 (BP2), (BP3), (BP4)가 바뀌어야 합니다. 지금부터 그 과정을 설명합니다.
                
                
            </div>
        </div>
        <br/><br/>
        <div class="row cnn">
            <div class="col-md-offset-2 col-md-8">
                <h3>5. CNN의 역전파 알고리즘 수식 </h3>
                <h4>5.1 컨벌루션Convolution 과 코릴레이션Correlation </h4>
                
                CNN은 입력층과 필터를 컨벌루션 한다고 일반적으로 이야기 합니다. 
                그런데 조금 자세히 살펴보면 여러 문서 마다 해당 연산을 두 가지로 기술하는 경우가 많습니다. 
                식(1), (2)가 바로 그것 입니다.[2] 
            
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ C(x,y)= \sum_{a=0}^{k-1} \sum_{b=0}^{k-1} I(x+a,y+b)F(a,b) $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                        식(1)
                    </div>
                </div>
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ C(x,y)= \sum_{a=0}^{k-1} \sum_{b=0}^{k-1} I(x-a,y-b)F(a,b) $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                        식(2)
                    </div>
                    
                </div>
                <div class="row eqexp">
                    <div class=" col-md-offset-2 col-md-8">
                    위 식에서, 
                    <span class="math-tex">\( I \)</span> : 2차원 입력 배열, 
                    <span class="math-tex">\( F \)</span> : 필터, 
                    <span class="math-tex">\( k \)</span>는 필터의 크기
                    </div>
                </div>
                
                
                식(1)을 '코릴레이션'이라 하고 식(2)를 '컨벌루션'이라 합니다. 
                둘의 차이는 코릴레이션은 필터 <span class="math-tex">\( F \)</span>를 입력 배열 <span class="math-tex">\( I \)</span>에 그대로 겹쳐놓고 
                같은 위치에 있는 요소끼리 곱해서 다 더하는 것입니다. 
                반면 컨벌루션은 필터 <span class="math-tex">\( F \)</span>를 180도 회전시켜서 같은 연산을 수행합니다. 
                컨벌루션의 수학적 정의가 식(3)과 같기 때문에 곱하고자 하는 함수를 반전시켜야 합니다. 
                (<span class="math-tex">\( g \)</span>함수의 <span class="math-tex">\( \tau \)</span>에 –가 곱해짐) 이와 동일한 행위가 2차원 배열에서는 180도 회전하는 것 입니다. 
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ f(t) * g(t) = \int^{\infty}_{-\infty} f(\tau)g(-\tau + t) d\tau $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                        식(3)
                    </div>
                </div>
                
                다음 jupyter 파일에서 연속함수의 컨벌루션과 배열의 180도 회전이 왜 동일한가 실험 해보았습니다. 참고 하세요.
                
                <p>
                <a href="./data/convolution.ipynb" class="btn btn-info">컨벌루션 주피터 파일</a>
                </p>
                <br/>
                
                식(2)의 인덱스 표현이 왜 필터를 180도 회전시키는 것인지 간단한 예제를 한번 그려 보면 금방 이해가 됩니다. 
                다음 엑셀파일에는 컨벌루션이 되는 모든 절차를 그려놓은 것입니다.
                
                <p>
                <a href="./data/conv.xls" class="btn btn-info">컨벌루션 그림 엑셀 파일</a>
                </p>
                <br/>
                
                인덱스 계산과 그림을 함께 보면 180도 회전에 대해 쉽게 이해 할 수 있습니다.
                
                식(2)의 경우는 필터가 입력 배열의 바깥으로 튀어 나가게 되는데, 입력이 없는 부분을 0으로 채우는 제로패딩zero-padding을 써서 문제를 해결합니다. 
                패딩 크기Padding size도 CNN의 하이퍼 파라메터hyper parameter중 하나입니다. 
                여기서는 이것을 다룰 목적은 아니므로 컨벌루션과 코릴레이션의 차이만 정확하게 알고 넘어가면 되겠습니다. 
                문서에 따라 이 둘을 모두 그냥 컨벌루션이라고 칭하는 문서도 많습니다. 
                UFLDL Tutorial[3]에 보면 매트랩의 Conv함수를 사용하면 필터를 회전시키기 때문에 회전시키지 않고 코릴레이션을 
                하기 위해 일부러 필터를 미리 돌려서 Conv함수에 넘겨주는 것을 확인할 수 있습니다. 
                컨벌루션과 코릴레이션의 정확한 개념 없이는 이런 부분이 매우 혼란스러울 수 있습니다. 
                우리 문서에서는 이 둘을 명확하게 구분 하도록 하겠습니다. 
                즉, 네트워크를 포워드패스Forward pass할 때 코릴레이션을 사용하도록 하겠습니다. 
                
            </div>
        </div>
        <br/><br/>
        <div class="row cnn">
            <div class="col-md-offset-2 col-md-8">
                <h4>5.2 예제 CNN 구조 </h4>
                이쯤에서 우리가 예로 들 CNN의 그림을 보도록 하겠습니다. 
                여기에 제시된 CNN은 어떤 기능을 수행하는 실제적 예가 아니라 
                인덱스 연산을 직접 해볼 수 있을 정도로 작으면서도 네트워크의 모양은 
                그럴듯하게 나오는 임의의 예제입니다. 
            </div>
        </div>
        <br/><br/>
        <div class="row cnn">
            <div class="col-md-offset-1 col-md-10">
            <img src="./images/fig1.png" class="img-responsive"></img>
            </div>
        </div>
        <br/><br/>
        <div class="row cnn">
            <div class="col-md-offset-2 col-md-8">
                이 모델은 15x15크기의 입력층으로 시작합니다. 
                그 뒤를 이어 4x4필터를 통해 12x12크기의 출력을 생성하고 이를 다시 2x2 크기로 맥스 풀링하여 
                6x6 크기의 출력을 만들어내는 컨벌루션층(이하 CONV층)이 있습니다. 
                다시 한번 3x3필터를 통해 4x4출력을 생성하고 맥스 풀링을 통해 2x2출력을 만들어내는 CONV층 이 있습니다. 
                그리고 마지막으로 2x2와 3x1이 완전히 연결되어 있는 완전연결층(이하 FC층)이 있습니다. 
                문제를 간단히 하기 위해 필터는 하나만 사용하고, 입력과 필터의 채널(깊이)수도 1로 둡니다.
                각 층은 색으로 구분되어 있으며 각 층의 인덱스가 아래쪽에 표시되어 있습니다. 
                그리고 각 층의 위쪽에는 역전파 중 사용되는 <span class="math-tex">\( a \)</span>, 
                <span class="math-tex">\( z \)</span>, <span class="math-tex">\( \delta \)</span>의 차원과 사용되는 행과 열의 인덱스가 표시되어 있습니다. 
                각 층의 바이어스도 표시되어 있습니다. 
                컨벌루션층의 바이어스는 배열이 아닌 상수로 표시되어 있습니다. 
                컨벌루션과 풀링은 이 네트워크에서 쌍으로 짝지어져 있어서 풀링층은 별도의 
                층 인덱스layer index를 부여하지 않았습니다. 
                그리고 CONV층의 출력을 <span class="math-tex">\( a \)</span>, 그 풀링층의 출력을 <span class="math-tex">\( \tilde{a} \)</span>로 표시했습니다. 
                2x2 맥스 풀링을 가정하므로 <span class="math-tex">\( \tilde{a} \)</span>의 크기는 <span class="math-tex">\( a \)</span>의 절반입니다. 
                CONV층을 2개 쌓은 이유는 FC층과 CONV층이 만나는 사이, CONV층과 CONV층이 만나는 사이에서 
                역전파 수식이 어떻게 다른지 살펴보기 위해서 입니다. 
                이제 이 모델에 대해서 순서대로 각 변수의 편미분 값을 구해보도록 하겠습니다.
            </div>
        </div>
        
        
        <br/><br/>
        <div class="row cnn">
            <div class="col-md-offset-2 col-md-8">
                <h4>5.3 단계별 역전파</h4>
                식(4)는 예제 CNN의 l번째 CONV 층에서의 가중 합을 코릴레이션을 사용하여 나타낸 것입니다. 
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ z^{l}_{mn}= \sum_{a=0}^{A-1}\sum_{b=0}^{B-1} w^{l}_{ab} a^{l-1}_{(m+a)(n+b)} + b^{l} $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                        식(4)
                    </div>
                </div>
                <div class="row eqexp">
                    <div class=" col-md-offset-2 col-md-8">
                    위 식에서 필터 <span class="math-tex">\( \mathbf{w} \)</span>의 크기는 A x B(전술한 바와 같이 인덱스의 대문자로 크기를 나타냄)
                    </div>
                </div>
                
                식(5)는 마지막 FC층의 가중합을 나타냅니다. 일반적인 NN에서 익숙하던 모습입니다.
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ z^{L}_{r}= \sum_{q} w^{l+2}_{rq} a^{l+1}_{q} + b^{l+2}_{r} $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                        식(5)
                    </div>
                </div>
                
                이 가중합을 활성화 함수를 통해 활성값으로 만들어 냅니다.
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ a^{l}_{mn} = \sigma ( z^{l}_{mn} ) $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                        식(6)
                    </div>
                </div>
                
                풀링을 사용한다면 정해진 풀링 유닛 크기만큼 활성값을 평균 내어 하나의 값을 구하거나(mean pooling), 
                풀링 유닛의 크기에 해당하는 활성값들 중 최대값을 선택(max pooling)하는 것으로 풀링층을 만들어 낼 수 있습니다. 
                이제 CNN역전파 알고리즘의 단계를 따라 가 보도록 하겠습니다. 
                지금부터는 그림과 그림의 인덱스와 수식을 함께 보면서 글을 읽어주세요.
                
            </div>
        </div>
        <br/><br/>
        <div class="row cnn">
            <div class="col-md-offset-2 col-md-8">
                <span class="label label-danger">단계 0</span>
                식(4)를 사용하여 네트워크 전체를 포워드패스 합니다. 마지막 완전연결 되어있는 층은 식(5)를 사용합니다. 단계0은 별 어려움이 없습니다. 열심히 계산만 하면 됩니다.
            </div>
        </div>
        <br/><br/>
        <div class="row cnn">
            <div class="col-md-offset-2 col-md-8">
                <span class="label label-danger">단계 1</span>
                (BP1)을 사용하여 출력층의 <span class="math-tex">\( \delta^{L} \)</span>을 구합니다. 
                출력층은 <span class="math-tex">\( l+1 \)</span> 번째 층과 완전연결 되어있는 층이므로 기존 역전파식과 달라질 것이 없습니다. 
                따라서 다음 식(CBP1)을 이용하여 출력층의 <span class="math-tex">\( \delta^{L} \)</span>을 구합니다.
            
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            \definecolor{spin}{RGB}{251,0,29}
                            \color{spin}
                            \delta^{L}_{r} = \frac{\partial C}{\partial a^{L}_{r}} \sigma'(z^{L}_{r}) 
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                        식(CBP1)
                    </div>
                </div>
                
            </div>
        </div>
        <br/><br/>
        <div class="row cnn">
            <div class="col-md-offset-2 col-md-8">
                <span class="label label-danger">단계 2</span>
                원래 역전파 알고리즘은 모든 층의  <span class="math-tex">\( \delta \)</span>를 구하고 
                다시 출력층으로 돌아와  <span class="math-tex">\( \mathbf{w} \)</span>와<span class="math-tex">\( \mathbf{b} \)</span>에 
                대한 편미분을 구하는 순서로 진행되지만 이 글에서는 설명의 편의를 위해 델타를 구한 후 
                바로 <span class="math-tex">\( \mathbf{w} \)</span>와 <span class="math-tex">\( \mathbf{b} \)</span>의 편미분을 구하도록 하겠습니다. 
                이전 단계와 마찬가지로 <span class="math-tex">\( \mathbf{w^{l+2}} \)</span>와 
                <span class="math-tex">\( \mathbf{b^{l+2}} \)</span>에 대한 코스트함수의 편미분 값은 
                기존의 (BP3), (BP4)를 통해 구할 수 있습니다.
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            \definecolor{spin}{RGB}{251,0,29}
                            \color{spin}
                            \frac{\partial C}{\partial b^{l+2}_{r}} = \delta^{l+2}_{r}
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2">
                        
                    </div>
                </div>
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            \definecolor{spin}{RGB}{251,0,29}
                            \color{spin}
                            \frac{\partial C}{\partial w^{l+2}_{rq}} = \tilde{a}^{l+1}_{q} \delta^{l+2}_{r}
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2">
                        
                    </div>
                </div>
                
                위 식에서 <span class="math-tex">\( \delta^{l+2}_{r} \)</span>는 단계 1을 통해서 다 구했고, 
                <span class="math-tex">\( \tilde{a}_{q}^{l+1} \)</span>은 포워드패스 과정에서 이미 모두 구해진 값입니다. 
                <span class="math-tex">\( l+1 \)</span>번째 층의 출력 <span class="math-tex">\( \tilde{a} \)</span>는
                <span class="math-tex">\( o' \)</span> , <span class="math-tex">\( p' \)</span>의 인덱스를 가지는 
                2차원 배열 형태이지만 그림처럼 1차원 배열로 간주하고 
                인덱스 <span class="math-tex">\( q \)</span>를 사용했습니다. 
                <span class="math-tex">\( o' \)</span> , <span class="math-tex">\( p' \)</span>와 
                <span class="math-tex">\( q \)</span>의 관계는 다음과 같습니다.
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            q = o'P + p'
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                        식(7)
                    </div>
                </div>
            </div>
        </div>
        <br/><br/>
        <div class="row cnn">
            <div class="col-md-offset-2 col-md-8">
            <img src="./images/fig2.png" class="img-responsive"></img>
            </div>
        </div>
        <br/><br/>
        <div class="row cnn">
            <div class="col-md-offset-2 col-md-8">
            따라서 우리는 <span class="math-tex">\( \delta_r^{l+2} \)</span>로 
            <span class="math-tex">\( \mathbf{b}^{l+2} \)</span> 에 대한 편미분 값을, 
            <span class="math-tex">\( \delta_r^{l+2} \)</span>와 
            <span class="math-tex">\( \tilde{a}_q^{l+1} \)</span>을 곱하는 것으로 
            <span class="math-tex">\( \mathbf{w}^{l+2} \)</span> 에 대한 편미분 값을 모두 구할 수 있습니다.
            </div>
        </div>
        <br/><br/>
        <div class="row cnn">
            <div class="col-md-offset-2 col-md-8">
                <span class="label label-danger">단계 3</span>
                이제 <span class="math-tex">\( \delta^{l+1} \)</span>을 구할 차례입니다. 
                그전에 <span class="math-tex">\( l+1 \)</span>번째 층은 CONV층이므로 
                <span class="math-tex">\( \frac{ \partial C }{ \partial w }\)</span>와
                <span class="math-tex">\( \frac{\partial C }{ \partial b } \)</span>를 먼저 유도하도록 하겠습니다. 
                <span class="math-tex">\( \mathbf{w}^{l+1} \)</span>과 <span class="math-tex">\( b^{l+1} \)</span>은 
                CONV층의 학습 변수이므로 FC층의 그것과 연결 양상이 다릅니다. 
                즉, <span class="math-tex">\( \mathbf{w}^{l+1} \)</span>는 부분적으로만 연결되어 있고, 
                <span class="math-tex">\( b^{l+1} \)</span>은 상수 하나가 모든 뉴런과 연결되어 있습니다. 
                <br/>
                예제 CNN에 맞춰서 식을 유도하면 인덱스를 p, q, m, n 와 같은 식으로 써야 하는데 이것은 
                별로 보기 좋지 않기 때문에 다음 그림처럼 익숙한 일반적인 인덱스 i, j를 가지는 부분 모델을 사용하겠습니다. 
                여기서의 인덱스는 예제 CNN모델과는 아무 상관이 없는 독립적인 인덱스입니다. 
            </div>
        </div>
        <br/><br/>
        <div class="row cnn">
            <div class="col-md-offset-2 col-md-8">
            <img src="./images/fig3.png" class="img-responsive"></img>
            </div>
        </div>
        <br/><br/>
        <div class="row cnn">
            <div class="col-md-offset-2 col-md-8">
                <span class="math-tex">\( N \times N \)</span> 크기의 <span class="math-tex">\( l-1 \)</span>번째 입력층에 
                <span class="math-tex">\( m \times m \)</span> 크기의 필터 <span class="math-tex">\( \mathbf{w} \)</span>를 적용하여 
                <span class="math-tex">\( (N-m+1) \times (N-m+1) \)</span> 크기의 출력층을 만드는 CONV층 모델입니다. 
                식(4)를 인덱스에 맞춰 다시 써보면 가중합 <span class="math-tex">\( z_{ij}^l \)</span> 는 식(8)과 같습니다.
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            z^{l}_{ij} = \sum_{a=0}^{m-1}\sum_{b=0}^{m-1} w^{l}_{ab} a^{l-1}_{(i+a)(j+b)} + b^{l}
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                        식(8)
                    </div>
                </div>
                
                이제 <span class="math-tex">\( \frac{\partial C}{\partial b^{l}} \)</span>은 다음처럼 체인룰로 표시할 수 있습니다.
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            \frac{\partial C}{\partial b^{l}} = \sum_{i=0}^{N-m}\sum_{j=0}^{N-m} \frac{\partial C}{\partial z^{l}_{ij}} \frac{\partial z^{l}_{ij}}{\partial b^{l}}
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                        식(9)
                    </div>
                </div>
                
                식(9)에서 <span class="math-tex">\( \frac{\partial z^{l}_{ij}}{\partial b^{l} } \)</span> 은 식(8)에 의해 모두 1입니다. 따라서 다시 써보면
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            \frac{\partial C}{\partial b^{l}} 
                            = \sum_{i=0}^{N-m}\sum_{j=0}^{N-m} \frac{\partial C}{\partial z^{l}_{ij}} \frac{\partial z^{l}_{ij}}{\partial b^{l}}
                            = \sum_{i=0}^{N-m}\sum_{j=0}^{N-m} \delta^{l}_{ij} \frac{\partial z^{l}_{ij}}{\partial b^{l} }
                            = \sum_{i=0}^{N-m}\sum_{j=0}^{N-m} \delta^{l}_{ij}
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                        식(10)
                    </div>
                </div>
                
                입니다. <b>(BP3)과 비교해보면 CONV층에서 <span class="math-tex">\( \frac{ \partial C }{ \partial b^{l} } \)</span>은  
                <span class="math-tex">\( \mathbf{\delta} \)</span>의 모든 엘리먼트를 다 더하는 것이 됩니다. </b>
                따라서 (CBP3)은 다음과 같습니다.
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            \definecolor{spin}{RGB}{251,0,29}
                            \color{spin}
                            \frac{\partial C}{\partial b^{l}} = \sum_{i=0}^{N-m}\sum_{j=0}^{N-m} \delta^{l}_{ij}
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                        (CBP3)
                    </div>
                    
                </div>
                <div class="row eqexp">
                    <div class=" col-md-offset-2 col-md-8">
                    위 식에서 
                    <span class="math-tex">\( N \)</span> : <span class="math-tex">\( l-1 \)</span>번째 층의 가로 세로 크기, 
                    <span class="math-tex">\( m \)</span>  : 필터 <span class="math-tex">\( \mathbf{w} \)</span>의 가로 세로 크기
                    </div>
                </div>
                
                이제 <span class="math-tex">\( \frac{\partial C}{\partial w^{l}_{ab}} \)</span>차례입니다. 
                역시 다음처럼 체인룰을 사용하여 표시할 수 있습니다.
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            \frac{\partial C}{\partial w^{l}_{ab}}
                            = \sum_{i=0}^{N-m}\sum_{j=0}^{N-m} 
                            \frac{\partial C}{\partial z^{l}_{ij}} 
                            \frac{\partial z^{l}_{ij}}{\partial w^{l}_{ab}}
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                        식(11)
                    </div>
                </div>
                
                식(11)에서 <span class="math-tex">\( \frac{\partial z^{l}_{ij}}{\partial w^{l}_{ab}} \)</span>은 식(8)에 의해 식(12)가 됩니다.
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            \frac{\partial z^{l}_{ij}}{\partial w^{l}_{ab}}
                            = a^{l-1}_{(i+a)(j+b)}
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                        식(12)
                    </div>
                </div>
                
                식(11)을 다시 써보면
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            \frac{\partial C}{\partial w^{l}_{ab}}
                            = \sum_{i=0}^{N-m}\sum_{j=0}^{N-m} 
                            \frac{\partial C}{\partial z^{l}_{ij}} 
                            a^{l-1}_{(i+a)(j+b)}
                            = \sum_{i=0}^{N-m}\sum_{j=0}^{N-m} 
                            a^{l-1}_{(i+a)(j+b)} \delta^{l}_{ij}
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                        식(13)
                    </div>
                </div>
                
                이 됩니다. 식(13)은 바로 <span class="math-tex">\( l-1 \)</span>번째 층 활성값 
                <span class="math-tex">\( \mathbf{a}^{l-1} \)</span>과 
                <span class="math-tex">\( \mathbf{\delta}^{l} \)</span>을 코릴레이션한 것입니다. 
                <b>(BP4)와 비교해보면 (BP4)는 <span class="math-tex">\( a\)</span>와 <span class="math-tex">\( \delta \)</span>를 
                행렬곱(열벡터에 행백터를 곱)한 식이고 
                CONV층에서는 <span class="math-tex">\( a\)</span>와 <span class="math-tex">\( \delta \)</span>를 코릴레이션 한 것입니다.</b>
                따라서 (CBP4)는 다음과 같습니다.
                
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            \definecolor{spin}{RGB}{251,0,29}
                            \color{spin}
                            \frac{\partial C}{\partial w^{l}_{ab}}
                            = \sum_{i=0}^{N-m}\sum_{j=0}^{N-m} 
                            a^{l-1}_{(i+a)(j+b)} \delta^{l}_{ij}
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                        (CBP4)
                    </div>
                </div>
                <div class="row eqexp">
                    <div class=" col-md-offset-2 col-md-8">
                    위 식에서 
                    <span class="math-tex">\( N \)</span> : <span class="math-tex">\( l-1 \)</span>번째 층의 가로 세로 크기, 
                    <span class="math-tex">\( m \)</span>  : 필터 <span class="math-tex">\( \mathbf{w} \)</span>의 가로 세로 크기
                    </div>
                </div>
                (CBP3)(CBP4)에서 볼 수 있듯이 입력층과 필터의 모양이 꼭 정방형일 필요는 없습니다. 대부분 정방형을 사용하므로
                여기서도 정방형으로 가정하고 이야기를 계속하도록 하겠습니다.
                
                이제 남은 것은 <span class="math-tex">\( \delta \)</span>를 구하는 것입니다. 
                <span class="math-tex">\( \delta^{l+1} \)</span>만 구하면 (CBP3), (CBP4)에 의해 
                <span class="math-tex">\( \frac{\partial C}{\partial b^{l+1}} \)</span>와 
                <span class="math-tex">\( \frac{\partial C}{\partial w_{cd}^{l+1}} \)</span>를 구할 수 있습니다. 
                <br/>
                다시 우리 CNN 모델로 돌아가도록 하겠습니다. 
                <span class="math-tex">\( \delta \)</span>의 정의에 따라 
                <span class="math-tex">\( \delta^{l+1} \)</span>은 식(14)입니다.
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            \delta^{l+1}_{op} = \frac{\partial C}{\partial z^{l+1}_{op}}
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                        식(14)
                    </div>
                </div>
                
                체인룰을 적용하면 식(15)와 같습니다.
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            \delta^{l+1}_{op} = 
                            \sum_{r}\sum_{o'}\sum_{p'}
                            \frac{\partial C}{\partial z^{l+2}_{r}} 
                            \frac{\partial z^{l+2}_{r}}{\partial \tilde{a}^{l+1}_{o'p'}}
                            \frac{\partial \tilde{a}^{l+1}_{o'p'}}{\partial a^{l+1}_{op}}
                            \frac{\partial a^{l+1}_{op}}{\partial z^{l+1}_{op}}
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                        식(15)
                    </div>
                </div>
                
                식(15)에 있는 인덱스 
                <span class="math-tex">\( o' \)</span>, 
                <span class="math-tex">\( p' \)</span>는 
                <span class="math-tex">\( q \)</span>로도 쓸 수 있으므로 
                인덱스 <span class="math-tex">\( q \)</span>를 쓰면 식(16)처럼 쓸 수 있습니다.
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            \delta^{l+1}_{op} = 
                            \sum_{r}\sum_{q}
                            \frac{\partial C}{\partial z^{l+2}_{r}} 
                            \frac{\partial z^{l+2}_{r}}{\partial \tilde{a}^{l+1}_{q}}
                            \frac{\partial \tilde{a}^{l+1}_{q}}{\partial a^{l+1}_{op}}
                            \frac{\partial a^{l+1}_{op}}{\partial z^{l+1}_{op}}
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                        식(16)
                    </div>
                </div>
                
                식(16)에서 <span class="math-tex">\( z_{r}^{l+2} \)</span>은 식(17)와 같습니다.
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            z_{r}^{l+2} = \sum_{q} w^{l+2}_{rq} \tilde{a}^{l+1}_{q} + b^{l+2}_{r}
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                        식(17)
                    </div>
                </div>
                
                식(17)에 의해 식(15)의 
                <span class="math-tex">\( \frac{\partial z_{r}^{l+2} }{\partial \tilde{a}^{l+1}_{o'p'}} \)</span>은 인덱스 
                <span class="math-tex">\( o' \)</span>,
                <span class="math-tex">\( p' \)</span>가 
                <span class="math-tex">\( q \)</span>와 같을 때를 제외하고는 모두 0입니다.
                
                따라서 <span class="math-tex">\( \frac{\partial z_{r}^{l+2} }{\partial \tilde{a}^{l+1}_{o'p'}} \)</span>은 식(18)과 같습니다.
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            \frac{\partial z_{r}^{l+2} }{\partial \tilde{a}^{l+1}_{o'p'}}
                            = \frac{\partial \sum_{q} w^{l+2}_{rq} \tilde{a}^{l+1}_{q} + b^{l+2}_{r} }{\partial \tilde{a}^{l+1}_{o'p'}}
                            = w^{l+2}_{rq}
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                        식(18)
                    </div>
                </div>
                <div class="row eqexp">
                    <div class=" col-md-offset-4 col-md-4">
                    위 식에서 
                    <span class="math-tex">\( q=o'P+p' \)</span>
                    </div>
                </div>
                
                식(18)과와 <span class="math-tex">\( \delta \)</span>의 정의를 적용하여 식(15)를 다시 써보면 식(19)가 됩니다.
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            \delta^{l+1}_{op} 
                            = \sum_{r}\sum_{o'}\sum_{p'} 
                            w^{l+2}_{rq} \delta^{l+2}_{r} \frac{\partial \tilde{a}^{l+1}_{o'p'}}{\partial a^{l+1}_{op}} \sigma'(z^{l+1}_{op})
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                        식(19)
                    </div>
                </div>
                
                식(19)에서 나타나는 인덱스 <span class="math-tex">\( q \)</span>는 
                <span class="math-tex">\( 2o'+p' \)</span>이므로 느닷없이 나타난 제3의 인덱스가 아니라 문제가 없습니다. 
                <br/>
                이제 식(19)에서 
                <span class="math-tex">\( \frac{\partial \tilde{a}^{l+1}_{o'p'}}{\partial a^{l+1}_{op}} \)</span>를 주목할 필요가 있습니다. 
                (BP2)와 비교해보면 
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            \delta^{l}_{j} 
                            = \sum_{k}
                            w^{l+1}_{kj} \delta^{l+1}_{k} \sigma'(z^{l}_{j})
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                        
                    </div>
                </div>
                
                <span class="math-tex">\( \frac{\partial \tilde{a}^{l+1}_{o'p'}}{\partial a^{l+1}_{op}} \)</span>
                는 새롭게 생겨난 항이라는 것을 알 수 있습니다. 
                
                <span class="math-tex">\( \frac{\partial \tilde{a}^{l+1}_{o'p'}}{\partial a^{l+1}_{op}} \)</span>
                는 무엇을 하는 것일까요? 무엇을 무엇에 대해 미분한다는 뜻일까요? 
                미분하면 어떤 현상이 일어나는 것일까요? Max 풀링의 경우를 놓고 생각해보겠습니다.
                
                <span class="math-tex">\( l+1 \)</span>층에서 일어나는 풀링은 아래그림과 같습니다. 
                4개의 뉴런 중 가장 큰 값을 취하고 나머지는 버립니다. 
                그림에서 풀링에 참가하는 뉴런을 같은색으로 표시했고 그 중 최대값은 조금 진하게 표시했습니다.
            </div>
        </div>
        <br/><br/>
        <div class="row cnn">
            <div class="col-md-offset-2 col-md-8">
            <img src="./images/fig4.png" class="img-responsive"></img>
            </div>
        </div>
        <br/><br/>
        <div class="row cnn">
            <div class="col-md-offset-2 col-md-8">
                결국 <span class="math-tex">\( \frac{\partial \tilde{a}^{l+1}_{o'p'}}{\partial a^{l+1}_{op}} \)</span>은 max 함수를 미분하는 것입니다. 
                <span class="math-tex">\( \tilde{a}^{l+1}_{o'p'} \)</span>는 식(20)처럼 max함수이기 때문입니다.
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            \tilde{a}^{l+1}_{o'p'} = \max [ nb( a^{l+1}_{op} ) ] 
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                        식(20)
                    </div>
                </div>
                
                여기서 <span class="math-tex">\( nb(a_{op}^{l+1}) \)</span>는 주어진 
                <span class="math-tex">\( a_{op}^{l+1} \)</span>와 함께 풀링되는 몇 개의 이웃들을 나타냅니다.
                <br/>
                예를 들어 <span class="math-tex">\( nb(a_{11}^{l+1}) \)</span>이라면 
                <span class="math-tex">\( a_{00}^{l+1} \)</span>, 
                <span class="math-tex">\( a_{01}^{l+1} \)</span>, 
                <span class="math-tex">\( a_{10}^{l+1} \)</span>, 
                <span class="math-tex">\( a_{11}^{l+1} \)</span>이 됩니다.
                
                또는 <span class="math-tex">\( nb(a_{01}^{l+1}) \)</span> 라면 결과는 역시 
                <span class="math-tex">\( a_{00}^{l+1} \)</span>, 
                <span class="math-tex">\( a_{01}^{l+1} \)</span>, 
                <span class="math-tex">\( a_{10}^{l+1} \)</span>, 
                <span class="math-tex">\( a_{11}^{l+1} \)</span>로 같게 됩니다.
                
                nb()는 나중에 정식화 하도록 하겠습니다. 
                
                그렇다면 <span class="math-tex">\( \frac{\partial \tilde{a}^{l+1}_{o'p'}}{\partial a^{l+1}_{op}} \)</span>라는 항은 
                분모의  <span class="math-tex">\( a^{l+1}_{op} \)</span>의 이웃들이 
                분자의  <span class="math-tex">\( \tilde{a}^{l+1}_{o'p'} \)</span>와 아무 상관없는 뉴런들이라면 0이 됩니다. 
                
                예를 들면 
                <span class="math-tex">\( \frac{\partial \tilde{a}^{l+1}_{00}}{\partial a^{l+1}_{02}} = 0\)</span>입니다. 
                이런 식으로 식(19)는 대부분의 경우 0이 되고 주어진 인덱스 
                <span class="math-tex">\( o \)</span>, 
                <span class="math-tex">\( p \)</span>와 상관 있는 
                <span class="math-tex">\( o' \)</span>, 
                <span class="math-tex">\( p' \)</span>에 대해서만 생각하면 됩니다. 
                즉, 인덱스 <span class="math-tex">\( o' \)</span>, 
                <span class="math-tex">\( p' \)</span>가 다음과 같은 경우를 제외하고는 식(19)는 모두 0입니다.
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            o' = \lfloor o/2 \rfloor \quad,\quad p' = \lfloor p/2 \rfloor
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                        
                    </div>
                </div>
                
                따라서 식(19)는 식(21)로 쓸 수 있습니다.
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            \delta^{l+1}_{op} 
                            = \sum_{r}
                            \left( w^{l+2}_{r,(2\lfloor o/2 \rfloor+\lfloor p/2 \rfloor)} \delta^{l+2}_{r} \right) 
                            \frac{\partial \tilde{a}^{l+1}_{\lfloor o/2 \rfloor \lfloor p/2 \rfloor}}{\partial a^{l+1}_{op}} \sigma'(z^{l+1}_{op})
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                        식(21)
                    </div>
                </div>
                
                식(21)에서 <span class="math-tex">\( \lfloor x \rfloor \)</span>는 x보다 작거나 같은 최대 정수입니다. 
                숫자 2는 풀링유닛의 행렬 크기입니다. 
                예를 들어 <span class="math-tex">\( o=1 \)</span>, 
                <span class="math-tex">\( p=2 \)</span>인 경우 
                <span class="math-tex">\( a^{l+1}_{12} \)</span>는 
                <span class="math-tex">\( \tilde{a}^{l+1}_{01} \)</span>을 제외한 나머지 
                <span class="math-tex">\( \tilde{a}^{l+1} \)</span>들과는 아무런 함수 관계가 없습니다. 
                
                따라서 
                <span class="math-tex">\( \frac{\partial \tilde{a}^{l+1}_{\lfloor o/2 \rfloor \lfloor p/2 \rfloor} }  {\partial a^{l+1}_{op}} \)</span>
                경우 외에 나머지는 모두 0이므로 
                <span class="math-tex">\( o \)</span>, 
                <span class="math-tex">\( p \)</span>에 대한 시그마 기호를 없앨 수 있습니다.
                또한 <span class="math-tex">\( w^{l+2}_{rq} \)</span>에서 인덱스 
                <span class="math-tex">\( q \)</span>를 식(7)에 의해 인덱스 <span class="math-tex">\( q \)</span>대신 
                <span class="math-tex">\( o \)</span>, 
                <span class="math-tex">\( p \)</span>로 나타내었습니다. 
                <br/>
                식(21)은 좌변에 인덱스 <span class="math-tex">\( o \)</span>와 <span class="math-tex">\( p \)</span>가 있고, 
                우변에도 인덱스 <span class="math-tex">\( o \)</span>와 <span class="math-tex">\( p \)</span>만 남게 되었습니다.
                (<span class="math-tex">\( r \)</span>은 시그마에 의해 확장되어 사라집니다.)
                즉, 식(21)에 <span class="math-tex">\( o \)</span>와<span class="math-tex">\( p \)</span>만 집어넣어 계산하면 
                <span class="math-tex">\( \delta^{l+1}_{op} \)</span>를 구할 수 있게 되었습니다. 
                그러기 위해서
                <span class="math-tex">\( \frac{\partial \tilde{a}^{l+1}_{\lfloor o/2 \rfloor \lfloor p/2 \rfloor} }  {\partial a^{l+1}_{op}} \)</span> 
                만 처리하면 됩니다. 
                식(20)에 의해
                <span class="math-tex">\( \frac{\partial \tilde{a}^{l+1}_{\lfloor o/2 \rfloor \lfloor p/2 \rfloor} }  {\partial a^{l+1}_{op}} \)</span> 
                는 max함수의 미분입니다. 
                Max 함수와 mean함수의 미분은 다음과 같습니다.[4]
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            g(\mathbf{x}) = max(\mathbf{x}), \quad 
                            \frac{\partial g}{\partial x_{i}} = 
                            \begin{cases}
                            1, & \mbox{if }  x_{i} = max(\mathbf{x}) \\
                            0, & \mbox{ otherwise }
                            \end{cases}
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                        식(22)
                    </div>
                </div>
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            g(\mathbf{x}) = \frac{\sum_{k=1}^{m} x_{k}}{m}, \quad
                            \frac{\partial g}{\partial x_{i}} = \frac{1}{m}
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                        식(23)
                    </div>
                </div>
                
                max함수의 미분값은 입력되는 변수벡터 <span class="math-tex">\( \mathbf{x} \)</span>중에서 제일 큰 변수로 미분할 때만 1, 나머지 경우 0입니다. 
                mean함수의 경우 어떤 변수로 미분을 해도 미분값은 항상 <span class="math-tex">\( \frac{1}{m} \)</span>입니다. 
                <span class="math-tex">\( m \)</span>은 평균 내는 변수들의 개수입니다. 
                이제 결론을 내리기 전에 식(21)을 역전파라는 시각에서 전체적으로 다시 조망해보도록 하겠습니다. 
                
            </div>
        </div>
        <br/><br/>
        <div class="row cnn">
            <div class="col-md-offset-2 col-md-8">
                <h4>5.3.1 역전파의 직관적 이해</h4>
                유명한 CS231n강의 "Intuitive understanding of backpropagation"[5] 장을 보면 
                식(24)와 같은 함수의 편미분을 예를들어 역전파를 설명하고 있습니다.
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            f(x,y) = \frac{x+\frac{1}{1+e^{-y}}}{\frac{1}{1+e^{-x}}+(x+y)^2}
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                        식(24)
                    </div>
                </div>
                
                강의에서는 위 식의 <span class="math-tex">\( x=3 \)</span>, <span class="math-tex">\( y=-4 \)</span>에서의 그래디언트gradient를 구하는 것을 보여줍니다. 
                식(24)를 <span class="math-tex">\(x\)</span>, <span class="math-tex">\(y\)</span>에 대해 편미분하기 위해서 체인룰을 써야하는데 
                이를 위해 부분함수들을 아래 그림과 같이 정의 하도록 하겠습니다.
            </div>
        </div>
        <br/><br/>
        <div class="row cnn">
            <div class="col-md-offset-2 col-md-8">
            <img src="./images/fig5.png" class="img-responsive"></img>
            </div>
        </div>
        <br/><br/>
        <div class="row cnn">
            <div class="col-md-offset-2 col-md-8">
                정의된 가장 외부 함수 <span class="math-tex">\( n \)</span>, 
                <span class="math-tex">\( d \)</span>에 대해서 체인룰을 적용해 가면서 미분을 해보면 각각 식(25), (26)이 됩니다.
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            \frac{\partial f}{\partial x} = 
                            \frac{\partial f}{\partial n} \frac{\partial n}{\partial x} +
                            \frac{\partial f}{\partial d} \frac{\partial d}{\partial h_1} \frac{\partial h_1}{\partial h_2} \frac{\partial h_2}{\partial h_3} \frac{\partial h_3}{\partial h_4} \frac{\partial h_4}{\partial x} +
                            \frac{\partial f}{\partial d} \frac{\partial d}{\partial h_5} \frac{\partial h_5}{\partial h_6} \frac{\partial h_6}{\partial x}
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                        식(25)
                    </div>
                </div>
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            \frac{\partial f}{\partial y} = 
                            \frac{\partial f}{\partial n} \frac{\partial n}{\partial g_1} \frac{\partial g_1}{\partial hg2} \frac{\partial g_2}{\partial g_3} \frac{\partial g_3}{\partial g_4} \frac{\partial g_4}{\partial y} +
                            \frac{\partial f}{\partial d} \frac{\partial d}{\partial h_5} \frac{\partial h_5}{\partial h_6} \frac{\partial h_6}{\partial y}
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                        식(26)
                    </div>
                </div>
                
                함수가 좀 복잡해서 꽤 긴 체인이 되었는데요, 
                아마 CS231n에서도 좀 실제적인 예를 보이기 위해 조금 복잡한 함수를 선택해서 설명을 하고 있는 것 같습니다. 
                미분 체인을 보면 전체 미분을 완성하기 위해 각 부분함수를 미분해서 지금까지 미분해온 체인에다 
                곱하는 것이라는 것을 알 수 있습니다. 
                즉, 각 부분함수에 대한 미분을 할 수 있으면 전체 함수의 미분을 손쉽게 끝낼 수 있습니다. 
                CS231n에서는 다음과 같이 이야기합니다. "Notice that backpropagation is a beautifully local process.". 
                좀 더 직관적인 이해를 위해 회로도식으로 살펴보도록 하겠습니다.
                
            </div>
        </div>
        <br/><br/>
        <div class="row cnn">
            <div class="col-md-offset-1 col-md-9">
            <img src="./images/fig6.png" class="img-responsive"></img>
            </div>
        </div>
        <br/><br/>
        <div class="row cnn">
            <div class="col-md-offset-2 col-md-8">
                위 그림에서 <span class="math-tex">\( x=3 \)</span>, 
                <span class="math-tex">\( y=-4 \)</span>를 대입하고 왼쪽에서 오른쪽으로 연산을 진행해 나가면 마지막에 
                <span class="math-tex">\( f \)</span>의 값을 구할 수 있습니다. 
                1.546입니다. 방금 우리가 한 것을 포워드 패스라 합니다. 
                포워드 패스과정에서 계산된 값을 검은색 글씨로 화살표 위쪽에 적었습니다. 
                이제 오른쪽에서 왼쪽으로 진행하면서 부분함수들에 대한 미분만 계산해 보겠습니다.
                우선 처음 <span class="math-tex">\( f \)</span>를 <span class="math-tex">\( f \)</span>에 대해 미분하면 1입니다. 붉은색으로 1을 표시했습니다. 
                <span class="math-tex">\( f \)</span>노드에서 위쪽 패스를 따라 가보겠습니다. 
                패스를 따라가다 보면 만나는 <span class="math-tex">\( f \)</span>에 대한 변수는 <span class="math-tex">\( n \)</span>입니다. 
                따라서 <span class="math-tex">\( n \)</span>과 <span class="math-tex">\( f \)</span>의 함수 관계만을 생각하면서 
                <span class="math-tex">\( f \)</span>를 <span class="math-tex">\( n \)</span>에 대해 미분하겠습니다.
                
                <span class="math-tex">\(f=n/d \)</span>이고 <span class="math-tex">\( \frac{\partial f}{\partial n}=\frac{1}{d} \)</span>이므로 
                <span class="math-tex">\( \frac{\partial f}{\partial n}=\frac{1}{1.952} \approx 0.512 \)</span>입니다. 
                이제 아래쪽 패스를 따라 가보겠습니다. 아래쪽 패스를 따라가면 <span class="math-tex">\( n \)</span>의 변수인 
                <span class="math-tex">\( g_{1} \)</span>을 만나게 됩니다. 
                <span class="math-tex">\( n=3+g_{1} \)</span>이므로 
                <span class="math-tex">\( \frac{\partial n}{\partial g_1}= 1 \)</span>입니다. 
                따라서 <span class="math-tex">\( \frac{\partial f}{\partial n} \frac{\partial n}{\partial g_1} \approx 0.512 \)</span> 임을 알 수 있습니다. 
                지금 우리는 부분함수의 미분만을 수행하면서 점점 식(26)의 미분체인 앞부분을 만들어 가고 있습니다. 한번만 더 해보겠습니다.
                <span class="math-tex">\( g_1= \frac{1}{g_2} \)</span>  이므로 
                <span class="math-tex">\(  \frac{\partial g_1}{\partial g_2} =  \frac{\partial \left( \frac{1}{g_2} \right) }{g_2} 
                = \frac{0 \cdot g_2 - 1 \cdot 1}{ g_{2}^{2} }
                                          = - \frac{1}{g^2_{2}} 
                                          = - \frac{1}{55.6^2}
                                          \approx -0.0003235 
                \)</span>입니다.
                
                따라서 미분체인은
                <span class="math-tex">\( 
                \frac{\partial f}{\partial n} \frac{\partial n}{\partial g_1} \frac{\partial g_1}{\partial g_2}
                =0.512×-0.0003235 \approx -0.000166 
                \)</span>
                로 계산됩니다. 
                
                이렇게 모든 패스에 대해 부분함수의 미분을 계산하고 앞에서 계산해둔 값에 그 값을 곱해나가는 작업을 반복적으로 
                하면서 전체 미분을 완성할 수 있습니다. 
                모든 계산이 끝난 후 <span class="math-tex">\( \frac{\partial f}{\partial x} \)</span>를 구하기 위해서 파란색 패스의 백워드 패스값을 모두 더하면 됩니다.
                <span class="math-tex">\( \frac{\partial f}{\partial y} \)</span>를 구하기 위해서는 초록색 패스의 백워드 패스값을 다 더하면 됩니다. 
                
                실제로 더해보면 
                <span class="math-tex">\( \frac{\partial f}{\partial x}=1.584+0.512+(-0.0359) \approx 2.06 \)</span>, 
                <span class="math-tex">\( \frac{\partial f}{\partial y}=1.584+(-0.00906) \approx 1.575 \)</span> 이고, 
                이 값은 CS231n에서 파이썬 코드[6]로 구한 값과 거의 일치합니다. 
                (회로도의 숫자는 제가 탁상용 계산기로 계산하면서 소수점 이하 숫자를 대충 반올림해서 오차가 좀 많이 생겼습니다.)
                <br/>
                역전파라는 과정을 통해서 미분값을 구하는 과정이 바로 위의 과정입니다. 
                이제 역전파의 구조를 이해 했으므로 식(16)과 식(21)이 다음 그림처럼 보이게 됩니다.
            </div>
        </div>
        <br/><br/>
        <div class="row cnn">
            <div class="col-md-offset-2 col-md-8">
            <img src="./images/fig7.png" class="img-responsive"></img>
            </div>
        </div>
        <br/><br/>
        <div class="row cnn">
            <div class="col-md-offset-2 col-md-8">
                이제 다시 max함수 또는 mean함수의 미분으로 돌아오겠습니다. 
                식(22),(23)에서 이미 두 함수의 미분을 알아보았습니다. 
                두 함수 모두 여러 개의 입력(변수 벡터)를 받아들여서 출력으로 하나의 값만을 내놓는 함수입니다. 
                아래 그림은 max함수의 경우를 예를 들어 설명한 것입니다. 
                위 그림에서 풀링 레이어 앞까지 미분체인에 의한 
                미분값 <span class="math-tex">\( \sum_{r} w_{rq}^{l+2} \delta_r^{l+2} \)</span>는 모두 계산이 된 상태입니다. 
                max함수를 미분하면 미분 결과는 미분하는 변수가 max함수로 입력된 변수중 최대일 경우는 1, 나머지는 0이 됩니다. 
                따라서 최대일 경우 앞쪽 미분 체인의 결과 
                <span class="math-tex">\( \sum_{r} w_{rq}^{l+2} \delta_{r}^{l+2} \)</span>에 1을 곱해서 해당 입력 패스쪽으로 보내고, 
                그렇지 않으면 0을 곱해서 해당 입력 패스쪽으로 보내는 결과를 낳게 됩니다.
                아래 그림은 그 과정을 보여주고 있습니다. 
            </div>
        </div>
        <br/><br/>
        <div class="row cnn">
            <div class="col-md-offset-2 col-md-8">
            <img src="./images/fig8.png" class="img-responsive"></img>
            </div>
        </div>
        <br/><br/>
        <div class="row cnn">
            <div class="col-md-offset-2 col-md-8">
                마치 특정 위치로 경로를 지정해서 값을 보내주는 것 같습니다. 
                그래서 CS231n에서도 이를 그래디언트를 라우트route한다라고 이야기합니다“The max gate routes the gradient.”. 
                Mean풀링의 경우는 다음 그림처럼 앞쪽 미분체인의 계산 값에 "1/[입력의 개수 또는 풀링유닛의 크기]"를 
                곱한 값을 모든 입력으로 뿌려주는 형태가 될 것입니다.[7] 
                이상과 같은 과정을 up-sampling이라 합니다. 
                up-sampling은 행렬의 모양을 맞추기 위해 인위적으로 이루어지는 것이 아니라 
                풀링 레이어의 미분 과정에서 자연스럽게 나타나게 됨을 알 수 있습니다.
            </div>
        </div>
        <br/><br/>
        <div class="row cnn">
            <div class="col-md-offset-2 col-md-8">
            <img src="./images/fig9.png" class="img-responsive"></img>
            </div>
        </div>
        <br/><br/>
        <div class="row cnn">
            <div class="col-md-offset-2 col-md-8">
                Up-sampling 까지 이야기 했으므로 식(21)을 이제 행렬 형태로 쓸 수 있습니다.
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            \mathbf{\delta}^{l+1} = \mbox{Upsampling}[ (\mathbf{w}^{l+1})^{T} \mathbf{\delta}^{l+2} ] \odot \sigma'(\mathbf{z}^{l+1})
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                        식(27)
                    </div>
                </div>
                
                식(21)과 식(27)을 비교하면 다음과 같습니다.
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            \definecolor{freq}{RGB}{45,177,93}
                            \definecolor{spin}{RGB}{251,0,29}
                            \definecolor{signal}{RGB}{18,110,213}
                            \delta^{l+1}_{op} 
                            = 
                            \color{signal} \sum_{r}
                            \left( w^{l+2}_{r,(2\lfloor o/2 \rfloor+\lfloor p/2 \rfloor)} \delta^{l+2}_{r} \right) 
                            \color{spin}
                            \frac{\partial \tilde{a}^{l+1}_{\lfloor o/2 \rfloor \lfloor p/2 \rfloor}}{\partial a^{l+1}_{op}} 
                            \color{freq}
                            \sigma'(z^{l+1}_{op})
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                    </div>
                </div>
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            \definecolor{black}{RGB}{0,0,0}
                            \definecolor{freq}{RGB}{45,177,93}
                            \definecolor{spin}{RGB}{251,0,29}
                            \definecolor{signal}{RGB}{18,110,213}
                            \mathbf{\delta}^{l+1} = 
                            \color{spin}
                            \mbox{Upsampling}[ 
                            \color{signal}
                            (\mathbf{w}^{l+1})^{T} \mathbf{\delta}^{l+2} 
                            \color{spin}
                            ] 
                            \color{black}
                            \odot 
                            \color{freq}
                            \sigma'(\mathbf{z}^{l+1})
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                    </div>
                </div>
                같은 역할을 하는 부분을 색깔로 표시했습니다. 
                뭔가 복잡하게 많은 과정을 거쳤지만 결과만 놓고 본다면 풀링레이어에 의해 upsampling되는 점만 제외하면 
                기존의 (BP2)와 크게 다른 것이 없는 식이 되었습니다. 
                <span class="math-tex">\(l+1\)</span>번째 층이 <span class="math-tex">\(l\)</span>번째 층과의 코릴레이션 연산에 의해 출력이 계산되는 CONV층이기는 하지만 
                이 층에 풀링레이어가 없다면 <span class="math-tex">\(l+2\)</span>번째 층과 그냥 완전 연결된 층이기 때문에 이는 당연한 결과 입니다. 
                즉, 델타를 구하는 BP2는 똑같고 CONV층이기 때문에 BP3, BP4만 달라지게 됩니다.(앞에서 CBP3, CBP4로 유도했습니다.) 
                그럼에도 불구하고 꽤 장황하게 일련의 미분 과정을 자세히 설명한 이유는 같은 논리를 
                그대로 (<span class="math-tex">\(l+1\)</span>번째 층이 CONV층인) <span class="math-tex">\(l\)</span>번째 층에 적용했을 때 결과가 
                좀 달라지게 되는데 그 과정을 잘 이해하기 위함입니다. 어떻게 달라지는지는 단계4에서 자세히 알아보겠습니다. 
                이제 마지막으로 앞에서 이야기했던 <span class="math-tex">\(nb()\)</span>를 정식화하여 단계3을 마무리 하도록 하겠습니다. 
                지금까지의 논의를 다시 식으로 써보면 <span class="math-tex">\( \delta^{l+1}_{op}  \)</span>를 구하는 과정은 식(28)과 같습니다.
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            \definecolor{spin}{RGB}{251,0,29}
                            \color{spin}
                            \delta^{l+1}_{op} = 
                            \sum_{r} \left( w^{l+2}_{r,(s \lfloor o/s \rfloor + \lfloor p/s \rfloor )} \delta^{l+2}_{r} \right) 
                            \frac{  \partial \tilde{a}^{l+1}_{\lfloor o/s \rfloor \lfloor p/s \rfloor} }{ \partial a^{l+1}_{op}  }
                            \sigma'(z^{l+1}_{op})
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                    식(28)
                    </div>
                </div>
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            \definecolor{spin}{RGB}{251,0,29}
                            \color{spin}
                            \frac{  \partial \tilde{a}^{l+1}_{\lfloor o/s \rfloor \lfloor p/s \rfloor} }{ \partial a^{l+1}_{op}  } = 
                            \begin{cases}
                            1, & \mbox{if }  a^{l+1}_{op} = max( nb(a^{l+1}_{op}) ) \\
                            0, & \mbox{ otherwise }
                            \end{cases} 
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                    </div>
                </div>
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            \definecolor{spin}{RGB}{251,0,29}
                            \color{spin}
                            nb(a^{l+1}_{op}) \equiv a^{l+1}_{t \in R_{1} , u \in R_{2}} \\ 
                            \color{spin}
                            R_{1} = [o-(o\%s), \quad o-(o\%s)+(s-1)] \\ 
                            \color{spin}
                            R_{2} = [p-(p\%s), \quad p-(p\%s)+(s-1)]
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                    </div>
                </div>
                <div class="row eqexp">
                    <div class=" col-md-offset-2 col-md-8">
                    위 식에서, 
                    <span class="math-tex">\( s  \)</span>는 풀링레이어 가로 세로 크기
                    </div>
                </div>
                
                <span class="math-tex">\( nb(a^{l+1}_{op}) \)</span>는 식(28)의 
                인덱스 범위 <span class="math-tex">\( R_{1} \)</span>, 
                <span class="math-tex">\( R_{2} \)</span>에 포함되는 인덱스를 가지는 
                <span class="math-tex">\( a^{l+1}_{op} \)</span>들을 가리킵니다. 
                
                예를 들어 <span class="math-tex">\( a^{l+1}_{21} \)</span>에 대해  
                <span class="math-tex">\( nb(a^{l+1}_{op}) \)</span>은 
                <span class="math-tex">\( R_{1}=[2, 3] \)</span>, 
                <span class="math-tex">\( R_{2}=[0, 1] \)</span>
                이므로 
                <span class="math-tex">\( a_{20}^{l+1}, a_{21}^{l+1}, a_{30}^{l+1}, a_{31}^{l+1}  \)</span>이 되고 
                이 4개의 뉴런은 <span class="math-tex">\( a_{21}^{l+1} \)</span> 과 함께 풀링되는 4개의 뉴런들이라는 것을 알 수 있습니다. 
                
                이제 <span class="math-tex">\( \delta_{op}^{l+1} \)</span>를 완전히 구했으므로 
                (CBP3), (CBP4)를 이용하여 
                <span class="math-tex">\( \frac{\partial C}{\partial b^{l+1}} , \frac{\partial C}{\partial w^{l+1}_{ab}} \)</span>
                을 구할 수 있습니다.
                <span class="math-tex">\( l+1 \)</span>층에서의 (CBP3), (CBP4)은 식(29)과 같습니다.        
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            \definecolor{spin}{RGB}{251,0,29}
                            \begin{align*} 
                            \color{spin}
                            \frac{\partial C}{\partial b^{l+1}} 
                            & \color{spin} =
                            \sum_{o=0}^{M'-C} \sum_{p=0}^{N'-D}
                            \delta^{l+1}_{op} 
                            \\
                            \color{spin}
                            \frac{\partial C}{\partial w^{l+1}_{cd}} 
                            & \color{spin} =
                            \sum_{o=0}^{M'-C} \sum_{p=0}^{N'-D} 
                            \tilde{a}^{l}_{(o+c)(p+d)} \delta^{l+1}_{op}
                            \end{align*}
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                    식(29)
                    </div>
                </div>
                
                단계3은 무척 길었습니다. 
                하지만 처음으로 CONV층의 미분을 완성하였습니다. 
                이제 남은 것은 l층에 대해 지금까지 했던 내용을 반복하는 것입니다. 
            </div>
        </div>
        <br/><br/>
        <div class="row cnn">
            <div class="col-md-offset-2 col-md-8">
                <span class="label label-danger">단계 4</span>
                이제 <span class="math-tex">\( \delta^{l} \)</span>을 구할 차례입니다. 
                이 층에서는 BP3과 BP4뿐만 아니라 BP2까지 수정이 되게 됩니다. 
                대부분의 내용이 단계3과 동일하나 <span class="math-tex">\( l \)</span>층은 
                <span class="math-tex">\( l+1 \)</span>층이 역시 CONV층이라는 점이 다릅니다. 
                단계3에서는 <span class="math-tex">\( l+1 \)</span>층은 CONV층, <span class="math-tex">\( l+2 \)</span>층은 FC층이었습니다. 
                아무튼 <span class="math-tex">\( \delta_{mn}^{l} \)</span>은 체인룰을 이용하여 식(30)과 같이 쓸 수 있습니다.
            
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            \delta^{l}_{mn} =
                            \frac{\partial C}{\partial z^{l}_{mn} } =
                            \sum_{m'} \sum_{n'} \sum_{o} \sum_{p} 
                            \frac{\partial C}{\partial z^{l+1}_{op}}
                            \frac{\partial z^{l+1}_{op}}{\partial \tilde{a}^{l}_{m'n'}}
                            \frac{\partial \tilde{a}^{l}_{m'n'}}{\partial a^{l}_{mn}}
                            \frac{\partial a^{l}_{mn}}{\partial z^{l}_{mn}}
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                    식(30)
                    </div>
                </div>
                식(30)을 역전파의 관점에서 보면 다음 그림과 같습니다. 즉, 단계3에서의 과정이 그대로 반복됨을 알 수 있습니다.
            </div>
        </div>
        <br/><br/>
        <div class="row cnn">
            <div class="col-md-offset-2 col-md-8">
            <img src="./images/fig10.png" class="img-responsive"></img>
            </div>
        </div>
        <br/><br/>
        <div class="row cnn">
            <div class="col-md-offset-2 col-md-8">
                위 식에서 <span class="math-tex">\( z^{l+1}_{op} \)</span>는 식(31)과 같습니다.
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            z^{l+1}_{op} = 
                            \sum_{c=0}^{C-1} \sum_{d=0}^{D-1}
                            \left[ w^{l+1}_{cd} \tilde{a}^{l}_{(o+c)(p+d)} \right] + b^{l+1}
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                    식(31)
                    </div>
                </div>
                
                이제 앞 단계에서와 같은 논리로 
                <span class="math-tex">\( \frac{\partial z^{l+1}_{op}}{\partial \tilde{a}^{l}_{m' n'}} \)</span>는 
                식(32)인 경우를 제외하고 모두 0이라는 것을 알 수 있습니다. 
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            m'=o+c \\
                            n'=p+d
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                    식(32)
                    </div>
                </div>
                식(32)에 의해
                <span class="math-tex">\( c=m'-o \)</span>, 
                <span class="math-tex">\( d=n'-p \)</span> 이므로 
                <span class="math-tex">\( \frac{\partial z^{l+1}_{op}}{\partial \tilde{a}^{l}_{m' n'}} \)</span>은 식(33)과 같습니다.
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            \frac{\partial z^{l+1}_{op}}{\partial \tilde{a}^{l}_{m' n'}} =
                            w^{l+1}_{(m'-o)(n'-p)}
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                    식(33)
                    </div>
                </div>
                
                이제 식(33)의 결과를 이용하여 식(30)을 다시 써보면 식(34)과 같습니다.
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            \delta^{l}_{mn} =
                            \frac{\partial C}{\partial z^{l}_{mn} } =
                            \sum_{m'} \sum_{n'} \sum_{o} \sum_{p} 
                            w^{l+1}_{(m'-o)(n'-p)} \delta^{l+1}_{op}
                            \frac{\partial \tilde{a}^{l}_{m'n'}}{\partial a^{l}_{mn}}
                            \frac{\partial a^{l}_{mn}}{\partial z^{l}_{mn}}
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                    식(34)
                    </div>
                </div>
                
                이제 여기서 다시 풀링레이어에 대한 미분 <span class="math-tex">\( \frac{\partial \tilde{a}^{l}_{m'n'}}{\partial a^{l}_{mn}} \)</span>을 처리하도록 하겠습니다. 
                역시나 이 미분은
                <span class="math-tex">\( m'= \lfloor \frac{m}{2} \rfloor \)</span>,
                <span class="math-tex">\( n'= \lfloor \frac{n}{2} \rfloor \)</span>
                인 경우를 제외하고는 모두 0입니다. 따라서 식(34)는 식(35)가 됩니다.
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            \delta^{l}_{mn} =
                            \sum_{o} \sum_{p} 
                            w^{l+1}_{(\lfloor m/2 \rfloor -o)(\lfloor n/2 \rfloor -p)} \delta^{l+1}_{op}
                            \frac{\partial \tilde{a}^{l}_{\lfloor m/2 \rfloor, \lfloor n/2 \rfloor}}{\partial a^{l}_{mn}}
                            \sigma'(z^{l}_{mn})
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                    식(35)
                    </div>
                </div>
                
                식(35)를 식(21)과 비교해보겠습니다.
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            \definecolor{black}{RGB}{0,0,0}
                            \definecolor{spin}{RGB}{251,0,29}
                            \delta^{l+1}_{op} = 
                            \color{spin}
                            \sum_{r}
                            \left( w^{l+2}_{r,(2\lfloor o/2 \rfloor+\lfloor p/2 \rfloor)} \delta^{l+2}_{r} \right) 
                            \color{black}
                            \frac{\partial \tilde{a}^{l+1}_{\lfloor o/2 \rfloor \lfloor p/2 \rfloor}}{\partial a^{l+1}_{op}} \sigma'(z^{l+1}_{op})
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                        
                    </div>
                </div>
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            \definecolor{black}{RGB}{0,0,0}
                            \definecolor{spin}{RGB}{251,0,29}
                            \delta^{l}_{mn} =
                            \color{spin}
                            \sum_{o} \sum_{p} \left(
                            w^{l+1}_{(\lfloor m/2 \rfloor -o)(\lfloor n/2 \rfloor -p)} \delta^{l+1}_{op}
                            \right)
                            \color{black}
                            \frac{\partial \tilde{a}^{l}_{\lfloor m/2 \rfloor \lfloor n/2 \rfloor}}{\partial a^{l}_{mn}}
                            \sigma'(z^{l}_{mn})
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                    
                    </div>
                </div>
                
                비교해보면 대부분 같지만 <span class="math-tex">\( w \)</span>와 
                <span class="math-tex">\( \delta \)</span>사이에서 일어나는 연산이 달라진 것을 확인할 수 있습니다. 
                <span class="math-tex">\( w \)</span>와 <span class="math-tex">\( \delta \)</span>사이에서 일어나는 연산은 어디에서 많이 본 듯합니다. 
                앞서 살펴본 식(2)를 다시 보겠습니다.
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ C(x,y)= \sum_{a=0}^{k-1} \sum_{b=0}^{k-1} I(x-a,y-b)F(a,b) $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                
                    </div>
                    
                </div>
                
                
                우리가 앞서 살펴본 컨벌루션식인 식(2)와  <span class="math-tex">\( \delta^{l}_{mn} \)</span>을 구할 때 
                 <span class="math-tex">\( w \)</span>와 <span class="math-tex">\( \delta \)</span>사이에서 일어나는 연산이 정확하게 
                 동일하다는 것을 알 수 있습니다. 
                즉, <span class="math-tex">\( \mathbf{\delta}^{l+1} \)</span>을 180도 돌려서 <span class="math-tex">\( \mathbf{w}^{l+1} \)</span>에 full 컨벌루션 하는 것입니다. 
                <span class="math-tex">\( \mathbf{w}^{l+1} \)</span>은 3x3이고 , 
                <span class="math-tex">\( \mathbf{\delta}^{l+1} \)</span>은 4x4입니다. 
                이를 full 컨벌루션 하면 6x6이 되고, 
                이것이
                <span class="math-tex">\( \frac{\partial \tilde{a}^{l}_{\lfloor m/2 \rfloor \lfloor n/2 \rfloor}}{\partial a^{l}_{mn}} \)</span>에 의해 
                up-sampling되면 12x12가 되어 <span class="math-tex">\( \delta^{l} \)</span>의 차원과 딱 맞게 됩니다. 
                단계3과 마찬가지로 이제 식(35)을 행렬형태로 써보면 식(36)과 같습니다.
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            \definecolor{black}{RGB}{0,0,0}
                            \definecolor{green}{RGB}{45,177,93}
                            \definecolor{red}{RGB}{251,0,29}
                            \definecolor{blue}{RGB}{18,110,213}
                            
                            \mathbf{\delta}^{l} = 
                            \color{red}
                            \mbox{Upsampling} [ 
                            \color{blue}
                            \mathbf{w}^{l+1} * \mathbf{\delta}^{l+1} 
                            \color{red}
                            ] 
                            \color{black}
                            \odot 
                            \color{green}
                            \sigma'(\mathbf{z}^{l})
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                        식(36)
                    </div>
                </div>
                
                행렬형태로 적으면 간결한 맛은 있지만, 
                내부적으로 무슨 일이 일어나고 있는지 한눈에 알 기가 힘들어진다는 단점이 있습니다. 
                그래서 본 글에서는 좀 복잡하지만 인덱스 형태의 식을 고집하였습니다. 
                단계3의 말미에도 언급하였지만 만약 풀링레이어가 없이 CONV층과 CONV층이 결합된 경우라면 어떻게 될까요? 
                그럼 식(35)은 식(37)와 같은 간단한 컨벌루션 연산만 남게 됩니다.
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            \delta^{l}_{mn} =
                            \sum_{o} \sum_{p} 
                            \left( w^{l+1}_{(m - o)(n - p)} \delta^{l+1}_{op} \right)
                            \sigma'(z^{l}_{mn})
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                    식(37)
                    </div>
                </div>
                
                정리하면 식(38)과 같이 <span class="math-tex">\( \delta^{l+1}_{mn} \)</span>을 구할 수 있습니다.
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            \definecolor{spin}{RGB}{251,0,29}
                            \color{spin}
                            \delta^{l}_{mn} = 
                            \sum_{o} \sum_{p} \left( w^{l+1}_{(\lfloor m/s \rfloor - o)(\lfloor n/s \rfloor - p)} \delta^{l+1}_{op} \right) 
                            \frac{  \partial \tilde{a}^{l}_{\lfloor m/s \rfloor \lfloor n/s \rfloor } }{ \partial a^{l}_{mn}  }
                            \sigma'(z^{l}_{mn})
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                    식(38)
                    </div>
                </div>
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            \definecolor{spin}{RGB}{251,0,29}
                            \color{spin}
                            \frac{  \partial \tilde{a}^{l}_{\lfloor m/s \rfloor \lfloor n/s \rfloor} }{ \partial a^{l}_{mn}  } = 
                            \begin{cases}
                            1, & \mbox{if }  a^{l+1}_{op} = max( nb(a^{l}_{mn}) ) \\
                            0, & \mbox{ otherwise }
                            \end{cases} 
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                    </div>
                </div>
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            \definecolor{spin}{RGB}{251,0,29}
                            \color{spin}
                            nb(a^{l}_{mn}) \equiv a^{l}_{t \in R_{1} , u \in R_{2}} \\ 
                            \color{spin}
                            \begin{align*} 
                            R_{1} & = [m-(m\%s), \quad m-(m\%s)+(s-1)] \\ 
                            \color{spin}
                            R_{2} & = [n-(n\%s), \quad n-(n\%s)+(s-1)]
                            \end{align*}
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                    </div>
                </div>
                <div class="row eqexp">
                    <div class=" col-md-offset-2 col-md-8">
                    위 식에서, 
                    <span class="math-tex">\( s  \)</span>는 풀링레이어 가로 세로 크기
                    </div>
                </div>
                
                이제 다음 (CBP3), (CBP4)를 이용해 
                <span class="math-tex">\( \frac{\partial C}{\partial b^{l}} \)</span>, 
                <span class="math-tex">\( \frac{\partial C}{\partial w^{l}_{ab}} \)</span>
                을 모두 구할 수 있습니다.
                
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            \definecolor{spin}{RGB}{251,0,29}
                            \begin{align*} 
                            \color{spin}
                            \frac{\partial C}{\partial b^{l}} 
                            & \color{spin} =
                            \color{spin}
                            \sum_{m=0}^{I-A} \sum_{n=0}^{J-B}
                            \delta^{l}_{mn} 
                            \\
                            \color{spin}
                            \frac{\partial C}{\partial w^{l}_{ab}} 
                            & \color{spin} =
                            \color{spin}
                            \sum_{m=0}^{I-A} \sum_{n=0}^{J-B} 
                            \tilde{a}^{l-1}_{(m+a)(n+b)} \delta^{l}_{mn}
                            \end{align*}
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                    
                    </div>
                </div>
                
            </div>
        </div>
        <br/><br/>
        <div class="row cnn">
            <div class="col-md-offset-2 col-md-8">
                <h4>5.4 정리</h4>
                
                꽤 길게 이야기를 했습니다. 
                하지만 이 긴 이야기를 세 줄로 정리하면 다음과 같습니다. 
                
                <h4>
                "코스트의 <br/>
                <b>
                [1] <span class="math-tex">\( \mathbf{w} \)</span>에 대한 편미분이 
                NN에서는 <span class="math-tex">\( \mathbf{a} \)</span>와 <span class="math-tex">\( \mathbf{\delta} \)</span>의 행렬곱으로 계산되나 
                CNN에서는 <span class="math-tex">\( \mathbf{a} \)</span>와 <span class="math-tex">\( \mathbf{\delta} \)</span>의 코릴레이션으로 계산된다.
                <br/>
                [2] <span class="math-tex">\( b \)</span>에 대한 편미분이 
                NN에서는 <span class="math-tex">\( \delta_{i} \)</span>이던 것이
                CNN에서는 모든 <span class="math-tex">\( \delta_{ij} \)</span>의 합으로 계산된다.
                <br/>
                [3] 역전파되는 <span class="math-tex">\( \mathbf{a} \)</span>에 대한 편미분이 
                NN에서는 <span class="math-tex">\( \mathbf{w} \)</span>와 <span class="math-tex">\( \mathbf{\delta} \)</span>의 행렬곱이던 것이 
                CNN 에서는 <span class="math-tex">\( \mathbf{w} \)</span>와 <span class="math-tex">\( \mathbf{\delta} \)</span>의 컨벌루션으로 계산된다."
                </b>
                </h4>
                
                이제 이상의 논의를 일반적인 인덱스를 써서 식 4개로 정리하도록 하겠습니다. 
                <h3>(CBP1)=(BP1)</h3>
                <h3>(CBP2)</h3>
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <h4>CONV-POOL-FC 인 경우</h4>
                        <span class="math-tex">
                            $$ 
                            \delta^{l}_{ij} = 
                            \sum_{k}
                            \left( w^{l+1}_{k,(s\lfloor i/s \rfloor+\lfloor j/s \rfloor)} \delta^{l+1}_{k} \right) 
                            \frac{\partial \tilde{a}^{l}_{\lfloor i/s \rfloor \lfloor j/s \rfloor}}{\partial a^{l}_{ij}} \sigma'(z^{l}_{ij})
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                        
                    </div>
                </div>
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <h4>CONV-POOL-CONV 인 경우</h4>
                        <span class="math-tex">
                            $$ 
                            \delta^{l}_{ij} =
                            \sum_{o} \sum_{p} \left(
                            w^{l+1}_{(\lfloor i/s \rfloor -o)(\lfloor j/s \rfloor -p)} \delta^{l+1}_{op}
                            \right)
                            \frac{\partial \tilde{a}^{l}_{\lfloor i/s \rfloor \lfloor j/s \rfloor}}{\partial a^{l}_{ij}}
                            \sigma'(z^{l}_{ij})
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                    
                    </div>
                </div>
                <div class="row eqexp">
                    <div class=" col-md-offset-2 col-md-8">
                        위 식에서, 
                        
                        <div class="row">
                            <div class=" col-md-offset-2 col-md-8">
                                <span class="math-tex">
                                    $$ 
                                    \frac{  \partial \tilde{a}^{l}_{\lfloor m/s \rfloor \lfloor n/s \rfloor} }{ \partial a^{l}_{mn}  } = 
                                    \begin{cases}
                                    1, & \mbox{if }  a^{l+1}_{op} = max( nb(a^{l}_{mn}) ) \\
                                    0, & \mbox{ otherwise }
                                    \end{cases} 
                                    $$  
                                </span> 
                            </div>
                            <div class="col-md-2 eqnum">
                            </div>
                        </div>
                        <div class="row">
                            <div class=" col-md-offset-2 col-md-8">
                                <span class="math-tex">
                                    $$ 
                                    nb(a^{l}_{mn}) \equiv a^{l}_{t \in R_{1} , u \in R_{2}} \\ 
                                    R_{1} = [m-(m\%s), \quad m-(m\%s)+(s-1)] \\ 
                                    R_{2} = [n-(n\%s), \quad n-(n\%s)+(s-1)]
                                    $$  
                                </span> 
                            </div>
                            <div class="col-md-2 eqnum">
                            </div>
                        </div>
                    </div>
                </div>
                <h3>(CBP3)</h3>
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                            \frac{\partial C}{\partial b^{l}} =
                            \sum_{i=0}^{N-m} \sum_{j=0}^{N-m} 
                            \delta^{l}_{ij} 
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                        
                    </div>
                </div>
                <h3>(CBP4)</h3>
                <div class="row">
                    <div class=" col-md-offset-2 col-md-8">
                        <span class="math-tex">
                            $$ 
                             \frac{\partial C}{\partial w^{l}_{ab}} =
                            \sum_{i=0}^{N-m} \sum_{j=0}^{N-m} 
                            a^{l-1}_{(i+a)(j+b)} \delta^{l}_{ij}
                            $$  
                        </span> 
                    </div>
                    <div class="col-md-2 eqnum">
                        
                    </div>
                </div>
                <div class="row eqexp">
                    <div class=" col-md-offset-2 col-md-8">
                        위 식에서,<br/>
                        <span class="math-tex">\( N \)</span>: <span class="math-tex">\( l-1 \)</span>층의 가로, 세로크기, <br/>
                        <span class="math-tex">\( m \)</span>: <span class="math-tex">\( l-1 \)</span>층과 
                        <span class="math-tex">\( l \)</span>층을 연결하는 필터의 가로, 세로크기
                    </div>
                </div>
            </div>
        </div>
        <br/><br/>
        <div class="row cnn">
            <div class="col-md-offset-2 col-md-8">
                <h3>6. 결론 </h3>
                
                우리는 CNN의 역전파 수식을 유도하면서 다음과 같은 사실을 알게 되었습니다.
                
                <ul>
                    <li>1. CNN에서의 역전파 수식을 인덱스형으로 모두 알 수 있다.</li>
                    <li>2. 합성함수의 편미분은 미분하고자 하는 함수를 블록다이어그램으로 표시하고 그 다이어그램을 역으로 거슬러 올라가는 과정으로 모델링될 수 있다.</li>
                    <li>3. 역전파 중 나타나는 컨벌루션은 인위적인 과정이 아니라 편미분하는 과정에서 자연스럽게 나타난다.</li>
                    <li>4. 역전파 중 나타나는 up-sampling 역시 인위적으로 행렬의 모양을 맞추기 위한 과정이 아니라 max 또는 mean 함수를 미분하는 과정에서 자연스럽게 일어난다.</li>
                </ul>
                
                최대한 자세하게 설명하기 위해 내용이 장황해진 것 같은 느낌이 듭니다. 
                하지만 제 글 쓰기 실력으로는 자세함과 간략함, 명쾌함을 모두 추구할 수 없었습니다. 
                이 내용을 제대로 이해하는데 3주가 걸렸고, 퇴근 후 아이를 재우고 조금씩 문서를 작성하다보니
                이해한 내용을 문서로 작성하는 데는 2달이 걸렸습니다. 
                장황한 설명임에도 불구하고 위 내용을 다 이해했다면 딥러닝 라이브러리를 쓰지 않고 python, numpy만으로 CNN을 구현할 수 있게 됩니다. 
                얼마전 출판된 <a href="http://www.aladin.co.kr/shop/wproduct.aspx?ItemId=99518713">"밑바닥부터 시작하는 딥러닝"</a>에서는 자세한 수식은 생략되었지만
                행렬 연산의 트릭을 이용해서 CONV층에 대한 구현을 일반적인 FC층과 동일하게 구현하는 놀라운 예제를 볼 수 있습니다.
                그렇게 구현하는것도 좋겠지만 속도가 좀 느려도 실제로 컨벌루션, 코릴레이션 연산을 명시적으로
                수행하는 코드를 만들어보는 것도 좋을 것 같습니다. 
                아마 누군가가 코드를 구현해서 공유해주실것으로 생각합니다.
                내용 중 오류가 있다면 꼭 연락 주시면 감사하겠습니다. 
            </div>
        </div>
        <br/><br/>
        <div class="row cnn">
            <div class="col-md-offset-2 col-md-8">
                <h3>7. 참고문헌 </h3>
                <ul>
                <li>[1] http://neuralnetworksanddeeplearning.com</li>
                <li>[2] http://www.jefkine.com/general/2016/09/05/backpropagation-in-convolutional-neural-networks/</li>
                <li>[3] http://ufldl.stanford.edu/tutorial/supervised/ExerciseConvolutionAndPooling/</li>
                <li>[4] http://www.slideshare.net/kuwajima/cnnbp</li>
                <li>[5] http://cs231n.github.io/optimization-2/</li>
                <li>[6] http://cs231n.github.io/optimization-2/#staged</li>
                <li>[7] http://ufldl.stanford.edu/tutorial/supervised/ExerciseConvolutionalNeuralNetwork/</li>
                </ul>
            </div>
        </div>
        <br/><br/>
        <footer>
            <div class="row cnn">
                <div class="col-md-offset-2 col-md-8">
                    <h3>
                    작성일 : 2017년 1월 23일
                    <br/>
                    작성자 : 조준우, metamath@gmail.com
                    </h3>
                </div>
            </div>
        </footer>
        <!--본문-->
        
        <!--css, js-->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
        
        
        <script src="https://code.jquery.com/jquery-3.1.1.min.js" integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=" crossorigin="anonymous"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
        
        <!--TeX-AMS_HTML-->
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config({
                displayAlign: "center",
                TeX: { extensions: ["color.js"] }
            }
            );
        </script>                          
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </body>
</html>